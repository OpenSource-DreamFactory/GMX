/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface PresaleInterface extends ethers.utils.Interface {
  functions: {
    "checkWhitelisted(bytes32[],bytes32,address)": FunctionFragment;
    "claim(uint256)": FunctionFragment;
    "coinContributed(address)": FunctionFragment;
    "contributeCoin()": FunctionFragment;
    "endTimestamp()": FunctionFragment;
    "expandPresale(uint256)": FunctionFragment;
    "forceRefund(address)": FunctionFragment;
    "getClaimableAmount(address)": FunctionFragment;
    "gift(address,uint256)": FunctionFragment;
    "initialize(address,address)": FunctionFragment;
    "launchPresale(uint256,uint256)": FunctionFragment;
    "maxPerWallet()": FunctionFragment;
    "merkleRoot()": FunctionFragment;
    "minPerWallet()": FunctionFragment;
    "owner()": FunctionFragment;
    "recoverCoin(address,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "salePrice()": FunctionFragment;
    "saleType()": FunctionFragment;
    "sellPublic(uint256)": FunctionFragment;
    "sellWhitelist(bytes32[],uint256)": FunctionFragment;
    "setTotalCap(uint256)": FunctionFragment;
    "startTimestamp()": FunctionFragment;
    "targetToken()": FunctionFragment;
    "targetTokenClaimed(address)": FunctionFragment;
    "targetTokenRequested(address)": FunctionFragment;
    "totalCoinContributed()": FunctionFragment;
    "totalTargetCap()": FunctionFragment;
    "totalTargetTokenRequested()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "udpateMerkleRoot(bytes32)": FunctionFragment;
    "updateMinMaxTokenPerWallet(uint256,uint256)": FunctionFragment;
    "updateSaleType(uint256)": FunctionFragment;
    "updateTokens(address,address)": FunctionFragment;
    "updateVTokenPrice(uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "checkWhitelisted",
    values: [BytesLike[], BytesLike, string]
  ): string;
  encodeFunctionData(functionFragment: "claim", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "coinContributed",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "contributeCoin",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "endTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "expandPresale",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "forceRefund", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getClaimableAmount",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "gift",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "launchPresale",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "maxPerWallet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "merkleRoot",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minPerWallet",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recoverCoin",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "salePrice", values?: undefined): string;
  encodeFunctionData(functionFragment: "saleType", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sellPublic",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "sellWhitelist",
    values: [BytesLike[], BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTotalCap",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "startTimestamp",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "targetTokenClaimed",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "targetTokenRequested",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "totalCoinContributed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalTargetCap",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "totalTargetTokenRequested",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "udpateMerkleRoot",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMinMaxTokenPerWallet",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateSaleType",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateTokens",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateVTokenPrice",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "checkWhitelisted",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "coinContributed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "contributeCoin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "endTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "expandPresale",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceRefund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getClaimableAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "gift", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "launchPresale",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "maxPerWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "merkleRoot", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "minPerWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "recoverCoin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "salePrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "saleType", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sellPublic", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTotalCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startTimestamp",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetTokenClaimed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "targetTokenRequested",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalCoinContributed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalTargetCap",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "totalTargetTokenRequested",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "udpateMerkleRoot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMinMaxTokenPerWallet",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateSaleType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateVTokenPrice",
    data: BytesLike
  ): Result;

  events: {
    "Gifted(address,uint256)": EventFragment;
    "Refunded(address,uint256,uint256)": EventFragment;
    "Requested(address,uint256,uint256)": EventFragment;
    "TransferOwnership(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Gifted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Refunded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Requested"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TransferOwnership"): EventFragment;
}

export type GiftedEvent = TypedEvent<
  [string, BigNumber] & { user: string; amount: BigNumber }
>;

export type RefundedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    user: string;
    amount: BigNumber;
    coin: BigNumber;
  }
>;

export type RequestedEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    user: string;
    deposit: BigNumber;
    coin: BigNumber;
  }
>;

export type TransferOwnershipEvent = TypedEvent<
  [string, string] & { _oldOwner: string; _newOwner: string }
>;

export class Presale extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: PresaleInterface;

  functions: {
    checkWhitelisted(
      _merkleProof: BytesLike[],
      _merkleRoot: BytesLike,
      _user: string,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    claim(
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    coinContributed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    contributeCoin(overrides?: CallOverrides): Promise<[string]>;

    endTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    expandPresale(
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    forceRefund(
      _user: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getClaimableAmount(
      user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    gift(
      _to: string,
      _vAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    launchPresale(
      _secAfter: BigNumberish,
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    maxPerWallet(overrides?: CallOverrides): Promise<[BigNumber]>;

    merkleRoot(overrides?: CallOverrides): Promise<[string]>;

    minPerWallet(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    recoverCoin(
      _to: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    salePrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    saleType(overrides?: CallOverrides): Promise<[BigNumber]>;

    sellPublic(
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sellWhitelist(
      merkleProof: BytesLike[],
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTotalCap(
      _totalAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    startTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    targetToken(overrides?: CallOverrides): Promise<[string]>;

    targetTokenClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    targetTokenRequested(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    totalCoinContributed(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalTargetCap(overrides?: CallOverrides): Promise<[BigNumber]>;

    totalTargetTokenRequested(overrides?: CallOverrides): Promise<[BigNumber]>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    udpateMerkleRoot(
      _merkelRoot: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateMinMaxTokenPerWallet(
      _minAmount: BigNumberish,
      _maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateSaleType(
      _saleType: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateTokens(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    updateVTokenPrice(
      _newSalePriceInResolution9: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  checkWhitelisted(
    _merkleProof: BytesLike[],
    _merkleRoot: BytesLike,
    _user: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  claim(
    _amount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  coinContributed(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  contributeCoin(overrides?: CallOverrides): Promise<string>;

  endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  expandPresale(
    _secDuration: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  forceRefund(
    _user: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getClaimableAmount(
    user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  gift(
    _to: string,
    _vAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _targetToken: string,
    _coinToken: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  launchPresale(
    _secAfter: BigNumberish,
    _secDuration: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

  merkleRoot(overrides?: CallOverrides): Promise<string>;

  minPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  recoverCoin(
    _to: string,
    _amount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  salePrice(overrides?: CallOverrides): Promise<BigNumber>;

  saleType(overrides?: CallOverrides): Promise<BigNumber>;

  sellPublic(
    _coinAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sellWhitelist(
    merkleProof: BytesLike[],
    _coinAmount: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTotalCap(
    _totalAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  startTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  targetToken(overrides?: CallOverrides): Promise<string>;

  targetTokenClaimed(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  targetTokenRequested(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  totalCoinContributed(overrides?: CallOverrides): Promise<BigNumber>;

  totalTargetCap(overrides?: CallOverrides): Promise<BigNumber>;

  totalTargetTokenRequested(overrides?: CallOverrides): Promise<BigNumber>;

  transferOwnership(
    _newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  udpateMerkleRoot(
    _merkelRoot: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateMinMaxTokenPerWallet(
    _minAmount: BigNumberish,
    _maxAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateSaleType(
    _saleType: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateTokens(
    _targetToken: string,
    _coinToken: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  updateVTokenPrice(
    _newSalePriceInResolution9: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    checkWhitelisted(
      _merkleProof: BytesLike[],
      _merkleRoot: BytesLike,
      _user: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    claim(_amount: BigNumberish, overrides?: CallOverrides): Promise<void>;

    coinContributed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contributeCoin(overrides?: CallOverrides): Promise<string>;

    endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    expandPresale(
      _secDuration: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    forceRefund(_user: string, overrides?: CallOverrides): Promise<void>;

    getClaimableAmount(
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gift(
      _to: string,
      _vAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      _targetToken: string,
      _coinToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    launchPresale(
      _secAfter: BigNumberish,
      _secDuration: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

    merkleRoot(overrides?: CallOverrides): Promise<string>;

    minPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    recoverCoin(
      _to: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    salePrice(overrides?: CallOverrides): Promise<BigNumber>;

    saleType(overrides?: CallOverrides): Promise<BigNumber>;

    sellPublic(
      _coinAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    sellWhitelist(
      merkleProof: BytesLike[],
      _coinAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setTotalCap(
      _totalAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    startTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    targetToken(overrides?: CallOverrides): Promise<string>;

    targetTokenClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    targetTokenRequested(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalCoinContributed(overrides?: CallOverrides): Promise<BigNumber>;

    totalTargetCap(overrides?: CallOverrides): Promise<BigNumber>;

    totalTargetTokenRequested(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      _newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    udpateMerkleRoot(
      _merkelRoot: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMinMaxTokenPerWallet(
      _minAmount: BigNumberish,
      _maxAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    updateSaleType(
      _saleType: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    updateTokens(
      _targetToken: string,
      _coinToken: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateVTokenPrice(
      _newSalePriceInResolution9: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "Gifted(address,uint256)"(
      user?: null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { user: string; amount: BigNumber }
    >;

    Gifted(
      user?: null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { user: string; amount: BigNumber }
    >;

    "Refunded(address,uint256,uint256)"(
      user?: null,
      amount?: null,
      coin?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; amount: BigNumber; coin: BigNumber }
    >;

    Refunded(
      user?: null,
      amount?: null,
      coin?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; amount: BigNumber; coin: BigNumber }
    >;

    "Requested(address,uint256,uint256)"(
      user?: null,
      deposit?: null,
      coin?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; deposit: BigNumber; coin: BigNumber }
    >;

    Requested(
      user?: null,
      deposit?: null,
      coin?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { user: string; deposit: BigNumber; coin: BigNumber }
    >;

    "TransferOwnership(address,address)"(
      _oldOwner?: null,
      _newOwner?: null
    ): TypedEventFilter<
      [string, string],
      { _oldOwner: string; _newOwner: string }
    >;

    TransferOwnership(
      _oldOwner?: null,
      _newOwner?: null
    ): TypedEventFilter<
      [string, string],
      { _oldOwner: string; _newOwner: string }
    >;
  };

  estimateGas: {
    checkWhitelisted(
      _merkleProof: BytesLike[],
      _merkleRoot: BytesLike,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claim(
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    coinContributed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    contributeCoin(overrides?: CallOverrides): Promise<BigNumber>;

    endTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    expandPresale(
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    forceRefund(
      _user: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getClaimableAmount(
      user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    gift(
      _to: string,
      _vAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    initialize(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    launchPresale(
      _secAfter: BigNumberish,
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    maxPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

    merkleRoot(overrides?: CallOverrides): Promise<BigNumber>;

    minPerWallet(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    recoverCoin(
      _to: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    salePrice(overrides?: CallOverrides): Promise<BigNumber>;

    saleType(overrides?: CallOverrides): Promise<BigNumber>;

    sellPublic(
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sellWhitelist(
      merkleProof: BytesLike[],
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTotalCap(
      _totalAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    startTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    targetToken(overrides?: CallOverrides): Promise<BigNumber>;

    targetTokenClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    targetTokenRequested(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    totalCoinContributed(overrides?: CallOverrides): Promise<BigNumber>;

    totalTargetCap(overrides?: CallOverrides): Promise<BigNumber>;

    totalTargetTokenRequested(overrides?: CallOverrides): Promise<BigNumber>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    udpateMerkleRoot(
      _merkelRoot: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateMinMaxTokenPerWallet(
      _minAmount: BigNumberish,
      _maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateSaleType(
      _saleType: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateTokens(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    updateVTokenPrice(
      _newSalePriceInResolution9: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    checkWhitelisted(
      _merkleProof: BytesLike[],
      _merkleRoot: BytesLike,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claim(
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    coinContributed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    contributeCoin(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    endTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    expandPresale(
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    forceRefund(
      _user: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getClaimableAmount(
      user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    gift(
      _to: string,
      _vAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    launchPresale(
      _secAfter: BigNumberish,
      _secDuration: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    maxPerWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    merkleRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    minPerWallet(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverCoin(
      _to: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    salePrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    saleType(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    sellPublic(
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sellWhitelist(
      merkleProof: BytesLike[],
      _coinAmount: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTotalCap(
      _totalAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    startTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    targetTokenClaimed(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    targetTokenRequested(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalCoinContributed(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    totalTargetCap(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    totalTargetTokenRequested(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    udpateMerkleRoot(
      _merkelRoot: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateMinMaxTokenPerWallet(
      _minAmount: BigNumberish,
      _maxAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateSaleType(
      _saleType: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateTokens(
      _targetToken: string,
      _coinToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    updateVTokenPrice(
      _newSalePriceInResolution9: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
